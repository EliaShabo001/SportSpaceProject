import React, { useState, useEffect } from "react";
import { Link } from "react-router-dom";
import {
  Box,
  Container,
  Grid,
  Card,
  CardContent,
  CardMedia,
  Typography,
  Button,
  TextField,
  InputAdornment,
  Slider,
  FormControl,
  FormGroup,
  FormControlLabel,
  Checkbox,
  Divider,
  Chip,
  Rating,
  IconButton,
  Drawer,
  useMediaQuery,
  useTheme,
  Paper,
  CircularProgress,
} from "@mui/material";
import SearchIcon from "@mui/icons-material/Search";
import FilterListIcon from "@mui/icons-material/FilterList";
import CloseIcon from "@mui/icons-material/Close";
import LocationOnIcon from "@mui/icons-material/LocationOn";
import StarIcon from "@mui/icons-material/Star";
import AccessTimeIcon from "@mui/icons-material/AccessTime";
import LocalParkingIcon from "@mui/icons-material/LocalParking";
import ShowerIcon from "@mui/icons-material/Shower";
import RestaurantIcon from "@mui/icons-material/Restaurant";
import WifiIcon from "@mui/icons-material/Wifi";
import { getAllFields } from "../../services/fieldsService";

// Mock data for fields (fallback)
const mockFields = [
  {
    id: 1,
    name: "Downtown Stadium",
    image: "https://source.unsplash.com/random/600x400/?football,stadium",
    location: "Central City",
    rating: 4.8,
    price: 50,
    type: "Indoor",
    capacity: "5v5",
    amenities: ["Parking", "Showers", "Cafeteria"],
    distance: 1.2,
  },
  {
    id: 2,
    name: "Riverside Field",
    image: "https://source.unsplash.com/random/600x400/?soccer,field",
    location: "Riverside District",
    rating: 4.6,
    price: 45,
    type: "Outdoor",
    capacity: "11v11",
    amenities: ["Parking", "Showers", "WiFi"],
    distance: 2.5,
  },
  // Add more mock fields as needed
];

const BrowseFields = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));
  const [mobileFiltersOpen, setMobileFiltersOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [priceRange, setPriceRange] = useState([0, 100]);
  const [selectedTypes, setSelectedTypes] = useState([]);
  const [selectedCapacities, setSelectedCapacities] = useState([]);
  const [selectedAmenities, setSelectedAmenities] = useState([]);
  const [sortBy, setSortBy] = useState("recommended");
  
  // State for fields data
  const [fields, setFields] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Fetch fields from Supabase
  useEffect(() => {
    const fetchFields = async () => {
      try {
        setLoading(true);
        const fieldsData = await getAllFields();
        
        // Transform data to match our expected format
        const transformedFields = fieldsData.map(field => ({
          id: field.id,
          name: field.name,
          image: field.image_url || `https://source.unsplash.com/random/600x400/?football,field,${field.id}`,
          location: field.location,
          rating: 4.5, // Default rating until we implement reviews
          price: field.hourly_rate,
          type: field.indoor ? "Indoor" : "Outdoor",
          capacity: field.capacity <= 10 ? "5v5" : field.capacity <= 14 ? "7v7" : "11v11",
          amenities: field.amenities ? JSON.parse(field.amenities) : [],
          distance: 2.5, // Mock distance until we implement geolocation
        }));
        
        setFields(transformedFields);
      } catch (err) {
        console.error("Error fetching fields:", err);
        setError("Failed to load fields. Please try again later.");
        // Fall back to mock data in case of error
        setFields(mockFields);
      } finally {
        setLoading(false);
      }
    };
    
    fetchFields();
  }, []);

  // Filter types
  const fieldTypes = ["Indoor", "Outdoor"];
  const capacityTypes = ["5v5", "7v7", "11v11"];
  const amenityTypes = ["Parking", "Showers", "Cafeteria", "WiFi"];

  // Handle filter changes
  const handleTypeChange = (type) => {
    if (selectedTypes.includes(type)) {
      setSelectedTypes(selectedTypes.filter((item) => item !== type));
    } else {
      setSelectedTypes([...selectedTypes, type]);
    }
  };

  const handleCapacityChange = (capacity) => {
    if (selectedCapacities.includes(capacity)) {
      setSelectedCapacities(
        selectedCapacities.filter((item) => item !== capacity)
      );
    } else {
      setSelectedCapacities([...selectedCapacities, capacity]);
    }
  };

  const handleAmenityChange = (amenity) => {
    if (selectedAmenities.includes(amenity)) {
      setSelectedAmenities(
        selectedAmenities.filter((item) => item !== amenity)
      );
    } else {
      setSelectedAmenities([...selectedAmenities, amenity]);
    }
  };

  // Filter fields based on criteria
  const filteredFields = fields.filter((field) => {
    // Search query filter
    if (
      searchQuery &&
      !field.name.toLowerCase().includes(searchQuery.toLowerCase()) &&
      !field.location.toLowerCase().includes(searchQuery.toLowerCase())
    ) {
      return false;
    }

    // Price range filter
    if (field.price < priceRange[0] || field.price > priceRange[1]) {
      return false;
    }

    // Type filter
    if (selectedTypes.length > 0 && !selectedTypes.includes(field.type)) {
      return false;
    }

    // Capacity filter
    if (
      selectedCapacities.length > 0 &&
      !selectedCapacities.includes(field.capacity)
    ) {
      return false;
    }

    // Amenities filter
    if (selectedAmenities.length > 0) {
      for (const amenity of selectedAmenities) {
        if (!field.amenities.includes(amenity)) {
          return false;
        }
      }
    }

    return true;
  });

  // Sort fields
  const sortedFields = [...filteredFields].sort((a, b) => {
    switch (sortBy) {
      case "price-low":
        return a.price - b.price;
      case "price-high":
        return b.price - a.price;
      case "rating":
        return b.rating - a.rating;
      case "distance":
        return a.distance - b.distance;
      case "recommended":
      default:
        return b.rating - a.rating; // Default sort by rating
    }
  });

  // Get amenity icon
  const getAmenityIcon = (amenity) => {
    switch (amenity) {
      case "Parking":
        return <LocalParkingIcon fontSize="small" />;
      case "Showers":
        return <ShowerIcon fontSize="small" />;
      case "Cafeteria":
        return <RestaurantIcon fontSize="small" />;
      case "WiFi":
        return <WifiIcon fontSize="small" />;
      default:
        return null;
    }
  };

  // Reset all filters
  const resetFilters = () => {
    setSearchQuery("");
    setPriceRange([0, 100]);
    setSelectedTypes([]);
    setSelectedCapacities([]);
    setSelectedAmenities([]);
    setSortBy("recommended");
  };

  // Filter sidebar content
  const filterContent = (
    <Box sx={{ p: isMobile ? 3 : 0 }}>
      {isMobile && (
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            mb: 2,
          }}
        >
          <Typography variant="h6" fontWeight={600}>
            Filters
          </Typography>
          <IconButton onClick={() => setMobileFiltersOpen(false)}>
            <CloseIcon />
          </IconButton>
        </Box>
      )}

      <Box sx={{ mb: 4 }}>
        <Typography variant="subtitle1" fontWeight={600} gutterBottom>
          Price Range (per hour)
        </Typography>
        <Slider
          value={priceRange}
          onChange={(e, newValue) => setPriceRange(newValue)}
          valueLabelDisplay="auto"
          min={0}
          max={100}
          sx={{ color: "primary.main" }}
        />
        <Box sx={{ display: "flex", justifyContent: "space-between" }}>
          <Typography variant="body2" color="text.secondary">
            ${priceRange[0]}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            ${priceRange[1]}
          </Typography>
        </Box>
      </Box>

      <Divider sx={{ my: 3 }} />

      <Box sx={{ mb: 4 }}>
        <Typography variant="subtitle1" fontWeight={600} gutterBottom>
          Field Type
        </Typography>
        <FormGroup>
          {fieldTypes.map((type) => (
            <FormControlLabel
              key={type}
              control={
                <Checkbox
                  checked={selectedTypes.includes(type)}
                  onChange={() => handleTypeChange(type)}
                  color="primary"
                />
              }
              label={type}
            />
          ))}
        </FormGroup>
      </Box>

      <Divider sx={{ my: 3 }} />

      <Box sx={{ mb: 4 }}>
        <Typography variant="subtitle1" fontWeight={600} gutterBottom>
          Capacity
        </Typography>
        <FormGroup>
          {capacityTypes.map((capacity) => (
            <FormControlLabel
              key={capacity}
              control={
                <Checkbox
                  checked={selectedCapacities.includes(capacity)}
                  onChange={() => handleCapacityChange(capacity)}
                  color="primary"
                />
              }
              label={capacity}
            />
          ))}
        </FormGroup>
      </Box>

      <Divider sx={{ my: 3 }} />

      <Box sx={{ mb: 4 }}>
        <Typography variant="subtitle1" fontWeight={600} gutterBottom>
          Amenities
        </Typography>
        <FormGroup>
          {amenityTypes.map((amenity) => (
            <FormControlLabel
              key={amenity}
              control={
                <Checkbox
                  checked={selectedAmenities.includes(amenity)}
                  onChange={() => handleAmenityChange(amenity)}
                  color="primary"
                />
              }
              label={
                <Box sx={{ display: "flex", alignItems: "center" }}>
                  {getAmenityIcon(amenity)}
                  <Typography sx={{ ml: 1 }}>{amenity}</Typography>
                </Box>
              }
            />
          ))}
        </FormGroup>
      </Box>

      <Button
        variant="outlined"
        color="primary"
        fullWidth
        onClick={resetFilters}
        sx={{ mt: 2 }}
      >
        Reset Filters
      </Button>
    </Box>
  );
